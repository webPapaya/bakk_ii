\section{Ruby}
\label{section: Ruby}

In diesem Kapitel wird die Programmiersprache Ruby kurz vorgestellt. Dieses Kapitel ist nicht mit einer Einführung in Ruby vergleichbar, da eine solche über den Rahmen dieser Arbeit hinausgehen würde. Das Buch Programming Ruby \cite[]{Dav05} bietet eine Einführung in die Sprache kann als Referenz dienen. 

Auf der Website \footnote{\url{http://www.ruby-lang.org}} definiert sich Ruby wie folgt:

\begin{quote}
	Ruby ist eine dynamische, freie Programmiersprache, die sich einfach anwenden und produktiv einsetzen lässt. Sie hat eine elegante Syntax, die man leicht lesen und schreiben kann. \cite[]{Rub92}
\end{quote}

Im Kern ist Ruby eine rein Objekt Orientierte Programmiersprache. Dabei besteht ein Objekt aus einer Kombination von Status und Methoden welche diesen Status verändern. \cite[p. 1-2]{Dav05}

Ruby wurde im Jahr 2012 von der ISO (International Organization for Standardization) mit dem Standard ISO/IEC 30170 \footnote{Den Standard kann man der Website \url{http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=59579} erwerben} standardisiert. Die Referenzimplementierung von Ruby ist CRuby oder MRI (Matz's Ruby Interpreter) \footnote{Der Quellcode ist auf Github verfügbar: \url{https://github.com/ruby/ruby}}.


\subsection{Concurrency in Ruby}

\subsubsection{Threads in Ruby}
In Ruby wird jedes Program in einem Thread ausgeführt. Dieser Main Thread wird beim ausführen eines Ruby Programms automatisch erstellt und ausgeführt. Wird der Main Thread beendet, so werden gleichzeitig alle anderen Threads der Applikation beendet und der Ruby Prozess wird beendet \cite[p. 15]{Sto2013}.

Um einen Thread in Ruby zu erzeugen erstellt man ein neues Thread Objekt und übergibt diesen einen Block. 

\begin{lstlisting}[language=Ruby,label=lst:thread_example]
def long_running
	sleep 2
	puts "second"
end
Thread.new { long_running }
puts "first"

# Output
#
# => first
# => second

\end{lstlisting}

In Listing \ref{lst:thread_example} sieht man ein Ruby Script welches einen Thread verwendet. Durch die Methode \emph{sleep} wird die Methode \textit{long\_run\_running} zwei Sekunden gestoppt. Im Beispiel sieht man dass die Zeile 6 als erstes auf dem Monitor ausgegeben wird als die Zeile 3. 

\cite[p. 21]{Sto2013}
\begin{lstlisting}[language=Ruby]
  100.times do
    Thread.new { sleep }
  end
  
  puts  "ps -o nlwp #{Process.pid}"
  sleep
\end{lstlisting} 

Dieses Programm erstellt 100 Threads und versetzt diese in einen schlafenden Zustand. Nachdem all Threads erstellt wurden wird der Main Thread in einen schlafenden Zustand versetzt. Daraus Resultiert, dass dieses Programm 101 Threads verwendet. 

Vergleicht man die unterschiedlichen Implementierungen von Ruby so kann man erkennen dass MRI, Rubinius, und JRuby weitere Threads zum verwalten von Ruby verwenden. MRI verwendet 1 zusätzlichen Thread zum verwalten. Bei JRuby und Rubinius richtet sich die Anzahl an Threads zum verwalten von Ruby an die verwendete CPU.

\subsubsection{Thread-Safety in Ruby}
In MRI (seit Version 1.9), Rubinius und JRuby werden Native Threads des Betriebssystems verwendet. Dadurch verwenden diese Implementierungen den Scheduler des Betriebssystems. Aus diesem Grund hat die Ruby Implementierung keinen Einfluss auf den genauen Zeitpunkt der Context-Switches. Dadurch können Race Conditions entstehen, welche für falsche Daten verantwortlich sind.

Der Conditional Assignment Operator in Ruby (||=) wird häufig verwendet um einer Variable einen Standardwert zu zuweisen. Dabei ist dieser Operator nicht Thread-Safe, da er keine Atomare Operation darstellt. Hinter diesem Operator steht eine Funktion welche wie folgt aussehen könnte \footnote{Die genaue Implementierung dieses Operators kann sich zwischen den einzelnen Ruby Implementierungen unterscheiden. Das Funktionsweise ist bei allen Implementierungen gleich}:

,caption={\cite[p. 24]{Sto2013}}

\begin{lstlisting}[language=Ruby,label={listing:conditional}]
	\# Dieser Ausdruck
	@results ||= "test" 

	\# Ist gleich diesem Ausdruck
	unless @results.defined?
		@results = "test"
	end
\end{lstlisting} 

In dem Listing \ref{listing:conditional} kann man erkennen das der Conditional Assignment Operator keine atomare Operation ist. Angenommen ein Programm möchte 10 Bilder aus dem Internet downloaden:

(TODO: Continue to Write on this section)

\subsubsection{The GIL in MRI}

Der GIL (Global Interpeter Lock) ist ein globaler Lock um der das parallele Ausführen von Ruby Code in einem Ruby Prozess verhindert. Das bedeutet, dass immer nur ein Ruby Thread pro Prozess einen Fortschritt machen kann. Wenn ein Thread einen fortschritt machen möchte muss er den GIL erhalten und darf nur dann einen fortschritt machen. Das bedeutet nicht dass in Ruby keine concurrent Applikationen geschrieben werden können, denn sobald ein Thread auf eine blockierende Operation trifft (z.B. I/O) dann wird der GIL an einen anderen Thread vergeben. Zu einem späteren Zeitpunkt erhält der blockierte Thread den GIL wieder und kann die Daten weiterverarbeiten. Das bedeutet jedoch das in MRI Ruby Code nie parallel laufen kann \cite[p. 42]{Sto2013}. 

Die Funktionsweise des MRI kann man anhand der Berechnung der Fibonacci Zahl \footnote{Weiter Informationen zur Fibonacci Zahlenfolge finden Sie auf \url{http://de.wikipedia.org/wiki/Fibonacci-Folge}} erklären. Bei diesem Beispiel sollten 4 mal die Fibonacci Zahlen bis 35 berechnet werden:

caption={\cite[p. 21]{Sto2013}}

\begin{lstlisting}[language=Ruby,label={listing:fibonacci}]
class Fibonacci
  def initialize(threads, number)
    @threads = Array.new(threads) { Thread.new {calculate number}}
    @threads.each(&:join)
  end

  #
  def calculate(number)
    return  number  if ( 0..1 ).include? number
    ( calculate( number - 1 ) + calculate( number - 2 ) )
  end
end

Fibonacci.new 4, 35
\end{lstlisting}

In Listing \ref{listing:fibonacci} wird die Fibonacci Zahl 4 mal berechnet. Dazu wird für jede Berechnung ein neuer Thread erstellt. Wird das Programm aus Listing \ref{listing:fibonacci} mit MRI ausgeführt so wird das Program wie folgt ausgeführt \footnote{Es wird nur die Funtionsweise der Zeilen 3-4 Beschrieben} \cite[p. 45-46]{Sto2013}: 

\begin{itemize}
  \item In Zeile 3 wird ein neues Array erstellt, welches mit 4 Threads initialisiert wird \footnote{Die Threads heißen in weiterer Folge Thread 1-4}.
  \item Jedem dieser Threads wird ein Block übergeben in dem die Funktion \emph{calculate} aufgerufen wird. Diese Funktion berechnet die Fibonacci Zahlen bis 35.
  \item Alle 4 Threads möchten einen Fortschritt machen. Jedoch darf nur der Thread einen Fortschritt machen, der den GIL besitzt. Aus diesem Grund werden alle Threads in einen Schlafzustand versetzt.
  \item Der Ruby Interpeter entscheidet, dass der Thread 2 den GIL erhält und weckt den Thread auf.
  \item Der Thread 2 berechnet die Zahlenfolge bis er fertig ist und gibt den GIL zurück an den Ruby Interpreter.
  \item Dieser entscheidet dass Thread 3 den GIL bekommt.
  \item Hat Thread 3 die Berechnung abgeschlossen wiederholt sich die selbe Prozedur für Thread 1 und Thread 4.
  \item Haben alle Threads die Berechnung beendet, ist das Programm abgeschlossen.
\end{itemize}

Der GIL ist eine Beschränkung von Parallelem ausführen von Ruby Code. Rubinius und JRuby heben den GIL auf und können dadurch Code parallel ausführen. Auch wenn der GIL eine große Beschränkung für das parallele Ausführen von Ruby Code darstellt gibt es Gründe warum das Team von MRI am GIL festhalten möchte. Hauptsächlich möchte man das Problem von Race Conditionen vermeiden \cite[p. 48-49]{Sto2013}.

Angenommen man besitzt folgendes Program\footnote{Idee von: \url{http://stackoverflow.com/questions/19969551/why-no-race-condition-in-ruby}}: 

\begin{lstlisting}[language=Ruby,label={listing:race condition}]

class Calculator
  attr_accessor :counter
  def initialize
    @counter = 0
  end
end

calculator = Calculator.new

threads = []
threads << Thread.new {100000.times { calculator.counter += 1 }}
threads << Thread.new {100000.times { calculator.counter += 1 }}
threads.each(&:join)

puts calculator.counter

\end{lstlisting}

In Listing \ref{listing:race condition} werden zwei Threads verwendet um eine Zahl 100000 mal zu erhöhen. Das Resultat der Berechnung sollte \emph{200 000} sein. Wird die Funktion mit MRI ausgeführt erhält man den Wert \emph{200 000}. Wird das Programm mit Rubinius oder JRuby ausgeführt erhält man den Wert \emph{200 000} nicht. 































Die Klasse Thread bietet einige Methoden um mit Threads in Ruby zu arbeiten. \footnote{Eine genaue Dokumentation findet sich unter \url{http://ruby-doc.org/core-2.2.0/Thread.html}}

\subsubsection{Fibers}
Fibers sind leichtgewichtige Objekte in Ruby welche Concurrency ermöglichen. Dabei akzeptieren Fibers Code Blöcke welche von der Applikation gestartet, pausiert und weitergeführt werden können. Im Unterschied zu Threads wird der Zeitplan von Fibers nicht von der Ausführenden Umgebung (Virtuellen Maschine) bestimmt sondern vom Programmierer. 

Jede Fiber besitzt einen eigenen 4kb großen Call-Stack der das Pausieren eines Fibers ermöglicht. Fibers werden nicht automatisch gestartet und müssen manuell vom Programmierer gestartet werden.

\begin{lstlisting}[language=Ruby,label=lst:thread_example]
def long_running
	sleep 2
	puts "second"
end
Thread.new { long_running }
puts "first"

# Output
#
# => first
# => second

\end{lstlisting}



\subsection{Ruby Implementierungen}

Für die Programmiersprache Ruby gibt es unterschiedliche Implementierungen auf welche ich in diesem Kapitel eingehen möchte. Folgende Implementierungen werden in dieser Arbeit nicht behandelt da diese entweder nicht mehr aktiv Weiterentwickelt werden oder für diese Arbeit keine Relevanz besitzten:

\begin{itemize}
  \item MacRuby
  \item MRuby
  \item IronRuby
  \item MegLev
  \item Cardinal
  \item Ruby Enterprise Edition
\end{itemize}

Compiler wie Rubymotion \footnote{Cross Plattform Ruby Compiler für IOS und Android \url{http://www.rubymotion.com/}}, welche Ruby Code in eine andere Programmiersprache kompilieren, werden in dieser Thesis ebenfalls nicht besprochen.

\subsection{CRuby}


\subsection{JRuby}


\subsection{Rubinius}
Rubinius ist eine Implementierung von Ruby welche sich auf Concurrency spezialisiert hat. Dabei verwendet es native Threads um Ruby Code auf allen CPUs laufen zu lassen. Rubinius wird nicht interpretiert sondern besitzt einen JIT (Just In Time) Compiler. Dabei wird der Ruby Code in Bytecode transformiert, welcher von der Ribinius Virtual Maschine ausgeführt wird. Die virtuelle Maschine ist in C und C++ geschrieben und verwendet Teile wie den Ruby Parser von MRI. Die Sprache Ruby ist selbst in Ruby implementiert und kann auf der Virtuellen Maschine ausgeführt werden. Dadurch ist Rubinius eine Implementierung die zu einem großen Teil in Ruby implementiert ist. 

