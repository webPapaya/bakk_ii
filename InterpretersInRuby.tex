\section{Ruby}
\label{section: Ruby}

Die Programmiersprache Ruby ist nicht für ihre Concurrency Features bekannt. Der Mythos dass der GIL (Global Interpreter Lock) concurrency in Ruby unmöglich macht hält sich bis heute. Dabei besitzt lediglich eine Implementierung von Ruby (CRuby) einen GIL. Diese unterbindet tatsächlich das parallele ausführen von Ruby. Das bedeutet jedoch nicht dass keine Operationen gleichzeitig behandelt werden können. Beim Thema Concurrency herscht aktuell der größte Unterschied zwischen den einzelnen Implementierungen von Ruby.

Ruby wurde im Jahr 2012 von der ISO (International Organization for Standardization) mit dem Standard ISO/IEC 30170 \footnote{Den Standard kann man der Website \url{http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=59579} erwerben} standardisiert. Die Referenzimplementierung von Ruby ist CRuby oder MRI (Matz's Ruby Interpreter) \footnote{Der Quellcode ist auf Github verfügbar: \url{https://github.com/ruby/ruby}}.

Auf der Website \footnote{\url{http://www.ruby-lang.org}} definiert sich Ruby wie folgt:

\begin{quote}
  Ruby ist eine dynamische, freie Programmiersprache, die sich einfach anwenden und produktiv einsetzen lässt. Sie hat eine elegante Syntax, die man leicht lesen und schreiben kann. \cite[]{Rub92}
\end{quote}

\subsection{Ruby Implementierungen}

Neben der Referenzimplementierung des ISO Standards gibt es noch weitere Implementierungen von Ruby. Die aktuell relevantesten Implementierungen sind CRuby (oder MRI), JRuby und Rubinius. Folgende Implementierungen werden in dieser Arbeit nicht behandelt da diese entweder nicht mehr aktiv Weiterentwickelt werden oder für diese Arbeit keine Relevanz besitzten:

\begin{itemize}
  \item MacRuby
  \item MRuby
  \item IronRuby
  \item MegLev
  \item Cardinal
  \item Ruby Enterprise Edition
\end{itemize}

Compiler wie Rubymotion \footnote{Cross Plattform Ruby Compiler für IOS und Android \url{http://www.rubymotion.com/}}, welche Ruby Code in eine andere Programmiersprache kompilieren, werden in dieser Thesis ebenfalls nicht behandelt.

\subsubsection{CRuby}
CRuby oder MRI (Matz's Ruby Interpreter) ist die Referenzimplementierung des Standards ISO/IEC 30170. CRuby wurde 1995 veröffentlicht und wird aktuell auf Github als OpenSource Projekt entwickelt. CRuby ist in C geschrieben und besitzt eine API mit der Extensions in C geschrieben werden können. Viele Gems wie Nokogiri (XML Parser) oder Psych (YAML Parser) verwenden in C geschriebene Bibliotheken. Nachdem viele dieser Bibliotheken nicht Thread-Safe sind besitzt CRuby einen GIL (Global Interpreter Lock), welcher das parallele Ausführen von Ruby Code verhindert. I/O Operationen können jedoch gleichzeitig behandelt werden. Seit Version 1.9 verwendet Ruby Native Threads des Betriebssystems. CRuby ist die am meisten verwendete Ruby Implementierung und ist für mehrere Plattformen verfügbar \footnote{Eine List an unterstützten Plattformen findet sich unter: \url{http://en.wikipedia.org/wiki/Ruby_MRI#Operating_systems}}.

\subsubsection{JRuby}

JRuby ist eine Implementierung von Ruby welche auf der JVM (Java Virtual Maschine) läuft. JRuby besitzt keine Möglichkeit auf C Extensions zurückzugreifen jedoch besitzt die Implementierung eine API für Java Bibliotheken. JRuby probiert so gut wie möglich die Kompatibelität mit CRuby zu behalten jedoch gibt es einige Punkte bei denen beide Implementierungen voneinander abweichen \footnote{Eine Liste von Unterschieden findet sich auf: \url{https://github.com/jruby/jruby/wiki/DifferencesBetweenMriAndJruby}}. 

\subsubsection{Rubinius}
Rubinius ist eine Implementierung von Ruby welche sich auf Concurrency spezialisiert hat. Dabei verwendet es native Threads um Ruby Code auf allen CPUs laufen zu lassen. Rubinius wird nicht interpretiert sondern besitzt einen JIT (Just In Time) Compiler. Dabei wird der Ruby Code in Bytecode transformiert, welcher von der Ribinius Virtual Maschine ausgeführt wird. Die virtuelle Maschine ist in C und C++ geschrieben und verwendet Teile wie den Ruby Parser von MRI. Viele der Sprachfeatures sind selbst in Ruby implementiert und kann auf der Virtuellen Maschine ausgeführt werden. Dadurch ist Rubinius eine Implementierung die zu einem großen Teil in Ruby implementiert ist. 

\subsection{Concurrency in Ruby}
Der Standard von Ruby beinhaltet einige Features um concurrency und paralleles Programmieren zu ermöglichen.

\subsubsection{Threads in Ruby}
In Ruby wird jedes Program in einem Thread ausgeführt. Dieser Main Thread wird beim Ausführen eines Ruby Programms automatisch erstellt und ausgeführt. Wird der Main Thread beendet, so werden gleichzeitig alle anderen Threads der Applikation beendet und der Ruby Prozess wird beendet \cite[p. 15]{Sto2013}.

Um einen neuen Thread in Ruby zu erzeugen erstellt man ein neues Thread Objekt und übergibt diesen einen Block. 

\begin{lstlisting}[language=Ruby,label=lst:thread_example]
def long_running
	sleep 2
	puts "second"
end
Thread.new { long_running }
puts "first"

# Output
#
# => first
# => second

\end{lstlisting}

In Listing \ref{lst:thread_example} sieht man ein Ruby Script welches einen Thread verwendet. Durch die Methode \emph{sleep} wird die Ausführung der Funktion \textit{long\_run\_running} zwei Sekunden gestoppt. Im Beispiel sieht man dass die Zeile 6 als erstes auf dem Monitor ausgegeben wird als die Zeile 3. 

\begin{lstlisting}[language=Ruby,caption=Adaptiert von \cite{Sto2013}]
  100.times do
    Thread.new { sleep }
  end
  
  puts  "ps -o nlwp #{Process.pid}"
  sleep
\end{lstlisting} 

Dieses Programm erstellt 100 Threads und versetzt diese in einen schlafenden Zustand. Nachdem all Threads erstellt wurden wird der Main Thread in einen schlafenden Zustand versetzt. Daraus Resultiert, dass dieses Programm 101 Threads verwendet. 

Vergleicht man die unterschiedlichen Implementierungen von Ruby so kann man erkennen dass MRI, Rubinius, und JRuby weitere Threads zum verwalten von Ruby verwenden. MRI verwendet 1 zusätzlichen Thread zum verwalten. Bei JRuby und Rubinius richtet sich die Anzahl an Threads zum verwalten von Ruby an die verwendete CPU.

\subsubsection{Thread-Safety in Ruby}
In MRI (seit Version 1.9), Rubinius und JRuby werden Native Threads des Betriebssystems verwendet. Dadurch verwenden diese Implementierungen den Scheduler des Betriebssystems. Aus diesem Grund hat die Ruby Implementierung keinen Einfluss auf den genauen Zeitpunkt der Context-Switches. Dadurch können Race Conditions entstehen, welche für falsche Daten verantwortlich sind.

Der Conditional Assignment Operator in Ruby (||=) wird häufig verwendet um einer Variable einen Standardwert zu zuweisen. Dabei ist dieser Operator nicht Thread-Safe, da er keine Atomare Operation darstellt. Hinter diesem Operator steht eine Funktion welche wie folgt aussehen könnte \footnote{Die genaue Implementierung dieses Operators kann sich zwischen den einzelnen Ruby Implementierungen unterscheiden. Das Funktionsweise ist bei allen Implementierungen gleich}:


\begin{lstlisting}[language=Ruby,label={listing:conditional}, caption={Adaptiert von \cite{Sto2013}, Seite 24}]
	# Dieser Ausdruck
	@results ||= "test" 

	# Ist gleich diesem Ausdruck
	unless @results.defined?
		@results = "test"
	end
\end{lstlisting} 

In dem Listing \ref{listing:conditional} kann man erkennen das der Conditional Assignment Operator keine atomare Operation ist. Angenommen ein Programm möchte 10 Bilder aus dem Internet downloaden:

(TODO: Continue to Write on this section)

\subsubsection{The GIL in MRI}

Der GIL (Global Interpeter Lock) ist ein globaler Lock um der das parallele Ausführen von Ruby Code in einem Ruby Prozess verhindert. Das bedeutet, dass immer nur ein Ruby Thread pro Prozess einen Fortschritt machen kann. Wenn ein Thread einen fortschritt machen möchte muss er den GIL erhalten und darf nur dann einen fortschritt machen. Das bedeutet nicht dass in Ruby keine concurrent Applikationen geschrieben werden können, denn sobald ein Thread auf eine blockierende Operation trifft (z.B. I/O) dann wird der GIL an einen anderen Thread vergeben. Zu einem späteren Zeitpunkt erhält der blockierte Thread den GIL wieder und kann die Daten weiterverarbeiten. Das bedeutet jedoch das in MRI Ruby Code nie parallel laufen kann \cite[p. 42]{Sto2013}. 

Die Funktionsweise des MRI kann man anhand der Berechnung der Fibonacci Zahl \footnote{Weiter Informationen zur Fibonacci Zahlenfolge finden Sie auf \url{http://de.wikipedia.org/wiki/Fibonacci-Folge}} erklären. Bei diesem Beispiel sollten 4 mal die Fibonacci Zahlen bis 35 berechnet werden:

\begin{lstlisting}[language=Ruby,label={listing:fibonacci},caption={Adaptiert von \cite{Sto2013}, Seite 21}]
class Fibonacci
  def initialize(threads, number)
    @threads = Array.new(threads) { Thread.new {calculate number}}
    @threads.each(&:join)
  end

  #
  def calculate(number)
    return  number  if ( 0..1 ).include? number
    ( calculate( number - 1 ) + calculate( number - 2 ) )
  end
end

Fibonacci.new 4, 35
\end{lstlisting}

In Listing \ref{listing:fibonacci} wird die Fibonacci Zahl 4 mal berechnet. Dazu wird für jede Berechnung ein neuer Thread erstellt. Wird das Programm aus Listing \ref{listing:fibonacci} mit MRI ausgeführt so wird das Program wie folgt ausgeführt \footnote{Es wird nur die Funtionsweise der Zeilen 3-4 Beschrieben} \cite[p. 45-46]{Sto2013}: 

\begin{itemize}
  \item In Zeile 3 wird ein neues Array erstellt, welches mit 4 Threads initialisiert wird \footnote{Die Threads heißen in weiterer Folge Thread 1-4}.
  \item Jedem dieser Threads wird ein Block übergeben in dem die Funktion \emph{calculate} aufgerufen wird. Diese Funktion berechnet die Fibonacci Zahlen bis 35.
  \item Alle 4 Threads möchten einen Fortschritt machen. Jedoch darf nur der Thread einen Fortschritt machen, der den GIL besitzt. Aus diesem Grund werden alle Threads in einen Schlafzustand versetzt.
  \item Der Ruby Interpeter entscheidet, dass der Thread 2 den GIL erhält und weckt den Thread auf.
  \item Der Thread 2 berechnet die Zahlenfolge bis er fertig ist und gibt den GIL zurück an den Ruby Interpreter.
  \item Dieser entscheidet dass Thread 3 den GIL bekommt.
  \item Hat Thread 3 die Berechnung abgeschlossen wiederholt sich die selbe Prozedur für Thread 1 und Thread 4.
  \item Haben alle Threads die Berechnung beendet, ist das Programm abgeschlossen.
\end{itemize}

Der GIL ist eine Beschränkung von Parallelem ausführen von Ruby Code. Rubinius und JRuby heben den GIL auf und können dadurch Code parallel ausführen. Auch wenn der GIL eine große Beschränkung für das parallele Ausführen von Ruby Code darstellt gibt es Gründe warum das Team von MRI am GIL festhalten möchte. Hauptsächlich möchte man das Problem von Race Conditionen vermeiden \cite[p. 48-49]{Sto2013}.

Angenommen man besitzt folgendes Program\footnote{Idee von: \url{http://stackoverflow.com/questions/19969551/why-no-race-condition-in-ruby}}: 

\begin{lstlisting}[language=Ruby,label={listing:race condition}]

class Calculator
  attr_accessor :counter
  def initialize
    @counter = 0
  end
end

calculator = Calculator.new

threads = Array.new(2) do
  Thread.new do
    100000.times { calculator.counter += 1 }
  end
end
threads.each(&:join)

puts calculator.counter

\end{lstlisting}

In Listing \ref{listing:race condition} werden zwei Threads verwendet um eine Zahl 100000 mal zu erhöhen. Das Resultat der Berechnung sollte \emph{200 000} sein. Wird die Funktion mit MRI ausgeführt erhält man den Wert \emph{200 000}. Wird das Programm mit Rubinius oder JRuby ausgeführt erhält man den Wert \emph{200 000} nicht. 

Obwohl MRI Race Conditionen vermeiden kann sind diese jedoch nicht ausgeschlossen wie folgendes Beispiel zeigt \footnote{Adaptiert von \url{http://stackoverflow.com/a/18576777/3002239}}:

\begin{lstlisting}[language=Ruby,label={listing:race condition mri},caption={Race Condition in Ruby MRI}]
$counter = 0

100.times.map do
  Thread.new do
    100.times do
      counter = $counter + 1
      sleep 0.001
      $counter = counter
    end
  end
end.each(&:join)

puts $counter 

\end{lstlisting}

In Listing \ref{listing:race condition mri} wird eine Globale Variable \emph{\$counter} erstellt. Nun werden 100 Threads erzeugt, welche die Variable \emph{\$counter} 100 mal erhöht. Am Ende sollte das Programm 10000 ausgeben, jedoch enthält dieses Programm eine Race Condition und liefert daher meistens ein falsches Ergebnis. In diesem Fall ist die Zeile 6 eine blockierende Operation und MRI verwendet blockierende Operationen um einen anderen Thread den GIL zu erteilen. Erhält der blockierte Thread den GIL wieder so ist der Wert von counter nicht der aktuelle Wert von  \emph{\$counter + 1} sondern der veralteter Wert zum Zeitpunkt an dem der Thread pausiert wurde. Dadurch wird in Zeile 8 ein veralteter Wert an der Variable \emph{\$counter} zugewiesen. 

Auch wenn ein solches Beispiel wie in Listing \ref{listing:race condition mri} in der Praxis eher selten auftreten wird, zeigt es dass auch mit einem GIL Race Conditions entstehen können.


\subsubsection{Mutex}
Mutex bieten die Möglichkeit Daten verschiedene Threads zu synchronisieren. Der Name Mutex kommt aus dem Englischen \emph{Mutual Exception}. Das Bedeutet, dass eine Sektion welche von einem Mutex umschlossen wurde nur von einem Thread zum selben Zeitpunk ausgeführt werden darf \cite[p. 81]{Sto2013}. 

In Ruby kann ein Mutex mit der Klasse Mutex\footnote{Dokumentation unter:  \url{http://ruby-doc.org/core-2.2.0/Mutex.html}} implementiert werden.


\begin{lstlisting}[language=Ruby,label={listing:race condition mutex}]
require 'thread'

$counter = 0
mutex = Mutex.new

100.times.map do
  Thread.new do
    100.times do
      mutex.lock
      counter = $counter + 1
      sleep 0.001
      $counter = counter
      mutex.unlock
    end
  end
end.each(&:join)

puts $counter # 10000
\end{lstlisting}

In Listing \ref{listing:race condition mri} konnte eine Race Kondition in MRI, Rubinius und JRuby entdeckt werden. Durch das Sperren des kritischen Codes durch einen Mutex in Listing \ref{listing:race condition mutex} wird eine Race Condition verhindert. Die Funktionsweise des Mutex ist wie folgt \cite[p. 83-84]{Sto2013}: 

\begin{itemize}
  \item Trifft der erste Thread auf den Mutex nimmt er diesen und sperrt die Ausführung des Codes und wird zum Besitzer des Mutex.
  \item Solange der erste Thread den Mutex besitzt darf kein andere Thread den Mutex für sich sperren. Dadurch kann kein anderer Thread den vom Mutex umschlossenen Code ausführen. 
  \item Hat der erste Thread den Code im Mutex ausgeführt, gibt er den Mutex frei. Dadurch ist der erste Thread nicht mehr Besitzer des Mutex und ein weiterer Thread kann den Mutex für sich sperren.
\end{itemize}

Das Sperren und Freigeben des Mutex wird direkt vom Betriebssystem verwaltet. Dabei gibt das Betriebssystem die Garantie dafür das kein anderer Thread diese Operation zur exakt selben Zeit ausführt. Durch die verwendung von Mutex in Listing \ref{listing:race condition mutex} wird die Operation \emph{Thread-Safe}.

Auf Linux kann ein Lock durch die C Funktion pthread\_mutex\_init(3) \footnote{\url{http://linux.die.net/man/3/pthread_mutex_init}} erstellt werden. Diese Funktion wird auch in MRI verwendet um einen Mutex zu erstellen \cite[p. 83-84]{Sto2013}. \footnote{Die Zeile in der ein Mutex in MRI erstellt wird: \url{https://github.com/ruby/ruby/blob/40564c1e3b187fc593001ae80522e577dbb8eb50/thread_pthread.c#L242}}.

Mutex kann zur synchronisierung von Daten verwendet werden. Jedoch können Teile einer Applikation welche durch einen Mutex gekapselt worden sind nicht parallel laufen. Ist ein Abschnitt in einer Applikation durch einen Mutex gekapselt, so kann dieser Teil nie parallel ausgeführt werden. Aus diesem Grund verwendet Ruby MRI auch einen Mutex für den GIL. Dadurch kann verhindert werden das Code parallel ausgeführt wird \cite[p. 91]{Sto2013}.

\subsection{Conditional Variables in Ruby}

\emph{Conditional Variables} bieten die Möglichkeit der Kommunikation zwischen einzelnen Threads. Dabei bieten sie einen Kontroll Mechanismus zwischen einzelnen Threads. Zum Beispiel kann ein Thread in einen schlafenden Zustand versetzt werden bis ein anderer Thread diesen Aufweckt. Die Nachrichten einer \emph{Conditional Variable} werden nicht zwischengespeichert, was bedeutet, dass eine Nachricht verloren geht, wenn diese nicht empfangen wurde \cite[p. 748]{tan09}.

Durch \emph{Conditional Variables} kann ein Thread in einen schlafenden Zustand versetzt werden, wenn dieser auf Daten eines anderen Threads wartet. Sind die Daten des anderen Threads bereit, kann dieser ein Signal an den schlafenden Thread versenden der diesen aufweckt. Dadurch muss der Thread nicht ständig den Status des anderen Threads pollen \cite[p. 100]{Sto2013}

\subsection{Thread-Safe Datenstrukturen in Ruby}
In Ruby gibt es nur eine Datenstruktur welche Thread Safe ist. Die Klasse \emph{Queue} bietet eine Möglichkeit zur synchronisierung von Threads. Die Klasse Queue besitzt einen blockierenden Charakter, was bedeutet, dass bei die Funktionen Push und Pop von einem Mutex umschlossen ist. Dadurch können keine \emph{Race Conditions} entstehen, welche zu korrupten Daten führen \cite[p. 110]{Sto2013}. 

Array und Hash sind weder in MRI noch in Rubinius und JRuby Thread Safe. Der Grund dafür liegt daran, dass Mutex in einem Single Threaded Kontext einen Overhead mit sich bringen, welcher sich signifikant auf die Performance der beiden Klassen niederschlagen würde \cite[p. 110]{Sto2013}.

Immutable Objekte sind Objekte welche nicht verändert werden kann, nachdem es erstellt wurde. Daraus Resultiert, dass diese Objekte Thread Safe sind. Ein Array, kann mit der Methode \emph{freeze} zu einem immutable Objekt konvertiert werden. Dadurch kann dem Array jedoch kein Element angefügt, entfernt oder modifiziert werden. Listing \ref{listing:immutable} zeigt ein immutable Array welches nicht modifiziert werden kann. 

\begin{lstlisting}[language=Ruby,label={listing:immutable}]
	array = [1,2,3].freeze
	array.push 4 # can't modify frozen Array (RuntimeError)
\end{lstlisting}

Eine Möglichkeit mit Immutable Datenstrukturen zu arbeiten bietet das gem \emph{hamster} \footnote{Dokumentation unter: \url{https://github.com/hamstergem/hamster}}. Dieses kopiert bei jeder Veränderung die originale Datenstruktur und verändert diese und gibt die veränderte Datenstruktur zurück. Dadurch bleibt die originale Struktur Datenstruktur immer gleich. 

\begin{lstlisting}[language=Ruby,label={listing:immuteable hamster}]
	require "hamster/vector"

	vector_original     = Hamster.vector 1, 2, 3
	vector_transformed  = vector_original.push 4

	puts vector_original.length # 3
	puts vector_transformed.length # 4
	puts vector_transformed.object_id == vector_original.object_id # false
\end{lstlisting}

In Listing \ref{listing:immuteable hamster} wird ein Hamster Vector Objekt erstellt, welches mit einem Array vergleichbar ist. In Zeile 3 wird ein neues \emph{Hamster.vector} Objekt erzeugt und mit den Werten \emph{1 ,2 ,3} initialisiert. Wird auf das neu initialisierte Objekt die Methode \emph{push} aufgerufen, so kopiert die Methode das alte Objekt fügt das neue Element \emph{4} an die Kopie an und friert die kopie ein. Nachdem aus dem Objekt ein Immutable Objekt geworden ist wird dieses Objekt zurückgegeben.



\subsection{Lambdas}
(TODO: check if we need this)
Lambdas werden auch als Closures, anonyme Functions oder Blocks genannt. Lambdas sind Blöcke aus Quellcode welcher als Argument an eine Funktion übergeben werden kann. Unter anderem werden Lambdas in den folgenden Programmiersprachen unterstützt:

\begin{itemize}
  \item Lisp
  \item Ruby
  \item Javascript
  \item Java
  \item Smalltalk
\end{itemize}

Closures können auf lokale Variablen zugreifen. Das bedeutet dass eine Closure auf alle Variablen im aktuellen Kontext zugriff haben. In der Sprache Ruby werden Closures unter anderem mit geschwungenen Klammeren erstellt. \cite[]{fow04}

\begin{lstlisting}[
  caption={},
  label=listing:closures
]
  File.open(filename) {|f| doSomethingWithFile(f)}
\end{lstlisting}
\cite[]{fow04}

In Listing \ref{listing:closures} wird eine Datei vom lokalem Filesystem geöffnet. Die Funktion open in der File Klasse akzeptiert einen Block als Argument. Die Funktion open öffnet die Datei, führt den angegebenen Block aus und schließt nach Ausführung des Blocks die Datei. Blöcke können unter anderem in Transaktionen verwendet werden. \cite[]{fow04}


(TODO: write about callbacks)
(TODO: write about callstack)