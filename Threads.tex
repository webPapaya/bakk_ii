\section{Threads}
\label{section: Threads}


(TODO: maybe cover those topics:)
%https://www.wikiwand.com/en/Parallel_Virtual_Machine
%https://www.wikiwand.com/de/Message_Passing_Interface
%http://www.open-mpi.org/

Prozess ist eine squentielle folge von Operationen welche keinen Speicher mit anderen Operationen teilen. (TODO: add to own subheading - maybe to introduction)


Threads sind Prozesse die sequentiell abgearbeitet werden jedoch den selben Speicher verwenden. \cite[p. 2]{Lee06} Es gibt Applikationen welche Threads


\subsection{Probleme bei verwendung von Multithreading}

\subsection{Race Conditions}

In mehrere parallel laufende Prozessen mit einem geteilten Speicher können Race Conditions auftreten, wenn dies Prozesse probieren auf die selbe Speicherstelle zu schreiben. Das kann zu unerwarteten Resultaten in der Programmierung führen wie der folgende Pseudocode zeigt. \ref[]{Net92}

\begin{lstlisting}[
	caption={},
	label=listing:race_conditions
]
if x == 10
	# Ein anderer Prozess veraendert die Variable x auf 12
	puts x # Output ist 12 
end
\end{lstlisting}

In Listing \ref{listing:race_conditions} ist zu sehen, dass durch einen anderen Prozess die Variable x auf einen anderen Wert gesetzt wird. Ob dieses Verhalten auftritt ist vom internen Scheduling der Prozesse abhängig. \ref[]{Net92}


\subsection{Deadlocks}

In einem Deadlock befinden sich mehrere Prozesse die jeweils auf eine Ressource warten, welche vom jeweilig anderen Prozess gesperrt ist. \cite[p. 1]{Jah04}

\subsubsection{The Dining Philosophers Problem}

Edsger Dijkstra beschreibt in seiner Thesis \emph{Hierarchical ordering of sequential processes} das Problem des Deadlocks anhand 5 Philosophen die gemeinsam an einem Tisch sitzen. Dabei beschreibt er folgendes problem:

\begin{quote}
	Five pholosophers numberd 0 through 4 are living in a house where the table laid for them, each philosopher has his own place hat the table. Their only problem - besides those of philosophy - is that the dish served is very difficult kind of spaghetti, that has to be eaten with two forks. There are two forks next to each plate, so that presents no difficulty: as a consequence, however, no two neighbours may be eating simultaniously. \cite[p. 21]{dij71}
\end{quote} 

Alle Philosophen sind mit ihren Gedanken so beschäftigt, dass sie nicht miteinander kommunizieren können. Damit einer der Philosophen essen kann benötigt er beide Gabeln. Eine mögliche Reihenfolge der Operationen die nötig sind damit ein Philosoph essen kann lauten wie folgt \cite[p. 21]{dij71}:

\begin{itemize}
  \item Denke nach
  \item Ist der Philosoph nicht hungrig? Gehe zu Schritt 1
  \item Ist die rechte Gabel nicht frei, Gehe zu Schritt 1
  \item Nimm die rechte Gabel
  \item Ist die linke Gabel nicht frei, Denke Nach und wiederhole diesen Schritt
  \item Nimm die linke Gabel
  \item Esse
  \item Lege rechte Gabel auf den Tisch  
  \item Lege linke Gabel auf den Tisch
  \item Gehe zu Schritt 1
\end{itemize}

Das Problem bei dieser Implementierung ist die Möglichkeit eines Deadlocks. Dieses kann entstehen wenn alle Philosophen zur gleichen Zeit hungrig werden und die jeweils rechte Gabel in die Hand nehmen. Nachdem die jeweils linke Gabel vom rechten Philosophen bereits besetzt ist, denken alle Philosophen so lange nach bis die rechte Gabel frei wird. In diesem Zustand wird keiner der Philosophen jemals satt werden \cite[p. 21]{dij71}. 

Das \emph{Dining Philosophers Problem} kann auf die Informatik angewendet werden bei dem mehrere parallel laufende Threads auf einen geteilten Speicher warten der vom jeweilig anderen Thread blockiert wird. 

\subsection{Threadsafety}



\subsection{Context Switching}

\url{https://wiki.haskell.org/Parallelism_vs._Concurrency}



\subsection{Green Threads}
Green Threads sind User-Level Threads welche nicht vom Kernel des Betriebssystems verwaltet werden, sondern von der Ausführungsumgebung. Dadurch müssen Green Threads 


 \cite[p.2]{Sun01}.


Green Threads vs System Threads

Deadlocks