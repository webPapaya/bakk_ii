\section{Prozesse und Threads}

Viele modernen Betriebssysteme können mehrere Operationen gleichzeitig ausführen. Zum Beispiel das Betriebssystem einen Browser und Textverarbeitungsprogramm gleichzeitig ausführen. Dieses Kapitel gibt einen Überblick über Prozesse und Threads. Eine detailierte Einführung in das Thema bietet das Kapitel 2 aus dem Buch Moderne Betriebssysteme von Andrew S. Tanenbaum. 


\subsection{Prozess}
\label{section: Prozess}
Tanenbaum beschreibt einen Prozess als ein Programm in Ausführung inklusive des aktuellen Wertes des Befehlszählers, der Registerinhalte und der Belegung der Variablen. Dabei besitzt jeder Prozess seine eigene virtuelle CPU, auf welcher der Prozess arbeiten darf. Um den Anschein einer parallelität für den BenutzerIn zu gewährleisten, wechselt die CPU zwischen einzelnen Programmen. Dadurch kann ein Betriebssystem, welches auf einem Computer mit Single Core Prozessor installiert ist, trotzdem mehrere Dinge gleichzeitig erledigen. Zum Beispiel kann ein Textverarbeitungsprogramm ausgeführt werden und gleichzeitig kann dieses eine Datei von der Festplatte öffnen \cite[p. 87]{tan09}.

In einem Betriebssystem werden eine Menge von sequentiellen Prozessen ausgeführt. Dabei kann man einen Prozess als ein Programm beschreiben, welches ausgeführt wird. Durch einen Scheduling Algorithmus werden die einzelnen Prozesse koordiniert und den Rechnzeiten auf der CPU zugewiesen. Die exakte Zeit wie lange ein Prozess für eine Aufgabe benötigt kann durch das Scheduling nicht genau bestimmt werden, da der Prozess nur seine Priorität beeinflussen kann. Jedoch unterliegt es dem Scheduling Algorithmus welcher Prozess wann auf der CPU ausgeführt wird \cite[p. 88]{tan09}. 

(TODO: add image Tannenbaum 88 Abb 2.1)

\subsection{Threads}
\label{section: Threads}
Ein Prozess besitzt immer nur einen Ausführungsfaden. Mehrere Prozesse können parallel oder quasi-parallel abgearbeitet werden jedoch können einzelne Prozesse nicht den gemeinsamen Adressraum teilen. Es gibt Situationen in denen eine Applikation mehrere Ausführungsfäden parallel bearbeiten möchte. Threads bieten die Möglichkeit mehrere Ausführungsfäden in einem Prozess auszuführen. Das ausführen von mehreren Threads in einem Prozess wird als Multithreading bezeichnet. Dabei besitzt ein Thread einen Befehlszeiger, ein Register und einen eigenen Stack. Der Befehlszeiger gibt an welcher Befehl als nächstes ausgeführt werden soll. Das Register beinhaltet alle lokalen Variablen. Im Stack werden aufgerufene Funktionen gestapelt welche noch nicht verlassen wurden. Durch den geteilten Adressraum zwischen den einzelnen Threads besitzen alle die selben globalen Variablen und diese lese, modifizieren oder löschen \cite[p. 97]{tan09}. 

Bei der Realisierung von Threads kann man prinzipiell zwischen drei Arten unterscheiden\footnote{Auf Threads in Kernel und Hybride Realisierungen wird in dieser Arbeit nicht eingegangen. Eine Einführung in Kernel Threads und Hybride Threads findet sich in \cite[p. 109-110]{tan09}}:

\begin{itemize}
  \item Threads im Benutzeradressraum
  \item Threads im Kernel 
  \item Hybride Realisierung von Threads
\end{itemize}

Bei einer Implementierung von Threads im Benutzerraum weiß das Betriebssystem von der Implementierung von Threads nichts. Wenn die Threads im Benutzerraum implementiert werden, benötigt jeder Thread seine eigene Thread Tabelle in der alle Threads des Prozesses verwaltet werden. Die Threads werden dabei von der Laufzeit verwaltet. Die implementierung von Threads im Benutzeradressraum wird auch als Green-Threads bezeichnet \cite[p. 106]{tan09}.

Blockierende Operationen wie das lesen eine I/O Operation kann von Threads im Adressraum realisiert werden, jedoch würde das alle weiteren Threads stoppen. Auf vielen UNIX Systemen gibt es die Funktion \emph{select}, welche überprüft ob eine Operation blockiert oder nicht. Wird die Operation blockiert, so wird ein anderer Thread ausgeführt. Wenn der blockierte Thread beim nächsten mal die Kontrolle bekommt, kann er ein weiteres mal überprüfen ob die operation blockiert. Dieser Vorgang wiederholt sich so lange, bis der Thread die Daten lesen kann \cite[p. 108]{tan09}. 


\subsection{Prozesse vs. Threads}

Prozesse und Threads teilen sich einige Eigenschaften. Beide Konzepte bieten die Möglichkeit Aufgaben parallel oder pseudo parallel zu bearbeiten. Prozesse teilen sich physische Ressourcen eines Computers wie Speicher, Festplatten, I/O Geräte, etc. Threads teilen sich den Adressraum und geöffnete Dateien eines Prozesses. Prozesse gehören immer zu genau einem Benutzer eines Betriebssystems. Threads hingegen gehören zu einem Prozess und besitzen dadurch nur indirekt einen Benutzer \cite[p. 89]{tan09}. 


\section{Probleme bei verwendung von Multithreading}

\subsection{Race Conditions}

In mehrere parallel laufende Threads mit einem geteilten Speicher können Race Conditions auftreten, wenn dies Prozesse probieren auf die selbe Speicherstelle zu schreiben. Das kann zu unerwarteten Resultaten in der Programmierung führen wie der folgende Pseudocode zeigt. \ref[]{Net92}
(TODO: refactor use tannenbaum)

\begin{lstlisting}[
	caption={},
	label=listing:race_conditions
]
if x == 10
	# Ein anderer Prozess veraendert die Variable x auf 12
	puts x # Output ist 12 
end
\end{lstlisting}

In Listing \ref{listing:race_conditions} ist zu sehen, dass durch einen anderen Prozess die Variable x auf einen anderen Wert gesetzt wird. Ob dieses Verhalten auftritt ist vom internen Scheduling der Prozesse abhängig. \ref[]{Net92}


\subsection{Deadlocks}

In einem Deadlock befinden sich mehrere Prozesse die jeweils auf eine Ressource warten, welche vom jeweilig anderen Prozess gesperrt ist. \cite[p. 1]{Jah04}

\subsubsection{The Dining Philosophers Problem}

Edsger Dijkstra beschreibt in seiner Thesis \emph{Hierarchical ordering of sequential processes} das Problem des Deadlocks anhand 5 Philosophen die gemeinsam an einem Tisch sitzen. Dabei beschreibt er folgendes problem:

\begin{quote}
	Five pholosophers numberd 0 through 4 are living in a house where the table laid for them, each philosopher has his own place hat the table. Their only problem - besides those of philosophy - is that the dish served is very difficult kind of spaghetti, that has to be eaten with two forks. There are two forks next to each plate, so that presents no difficulty: as a consequence, however, no two neighbours may be eating simultaniously. \cite[p. 21]{dij71}
\end{quote} 

Alle Philosophen sind mit ihren Gedanken so beschäftigt, dass sie nicht miteinander kommunizieren können. Damit einer der Philosophen essen kann benötigt er beide Gabeln. Eine mögliche Reihenfolge der Operationen die nötig sind damit ein Philosoph essen kann lauten wie folgt \cite[p. 21]{dij71}:

\begin{itemize}
  \item Denke nach
  \item Ist der Philosoph nicht hungrig? Gehe zu Schritt 1
  \item Ist die rechte Gabel nicht frei, Gehe zu Schritt 1
  \item Nimm die rechte Gabel
  \item Ist die linke Gabel nicht frei, Denke Nach und wiederhole diesen Schritt
  \item Nimm die linke Gabel
  \item Esse
  \item Lege rechte Gabel auf den Tisch  
  \item Lege linke Gabel auf den Tisch
  \item Gehe zu Schritt 1
\end{itemize}

Das Problem bei dieser Implementierung ist die Möglichkeit eines Deadlocks. Dieses kann entstehen wenn alle Philosophen zur gleichen Zeit hungrig werden und die jeweils rechte Gabel in die Hand nehmen. Nachdem die jeweils linke Gabel vom rechten Philosophen bereits besetzt ist, denken alle Philosophen so lange nach bis die rechte Gabel frei wird. In diesem Zustand wird keiner der Philosophen jemals satt werden \cite[p. 21]{dij71}. 

Das \emph{Dining Philosophers Problem} kann auf die Informatik angewendet werden bei dem mehrere parallel laufende Threads auf einen geteilten Speicher warten der vom jeweilig anderen Thread blockiert wird. 

\subsection{Context Switching}
Um einen möglichst faieren Zugriff auf die CPU für einzelne Threads zu bieten kann das Betriebssystem einzelne Threads zu jeder Zeit stoppen und zu einem späteren Zeitpunkt wieder ausführen. Der Zeitpunk wann ein Thread gestoppt werden soll und wann dieser wieder weiter ausgeführt werden soll wird von dem \emph{Scheduler} des Betriebssystems bestimmt. Die übergabe von CPU Ressourcen von einem Thread an den anderen wird als Context-Switch bezeichnet \cite[p. 23]{Sto2013}. 






