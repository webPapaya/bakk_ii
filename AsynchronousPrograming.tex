\section{Asynchrone Programmierung}

In der Literatur wird zwischen den Begriffen Blocking und Synchrone Programmierung und den Begriffen Non-Blocking und Asynchrone Programmierung oft keine differenzierung getroffen. In diesem Kapitel werden die Begriffe Blocking, Non-Blocking, Synchrone Programmierung und Asynchrone Programmierung näher erläutert. Als Grundlage für die Beschreibung der einzelnen Begriffe dient ein Beispiel aus der Informatik. 

Drei voneinander unabhängige Aufgaben sollen von einem Computer ausgeführt werden. Alle drei Aufgaben müssen abgeschlossen sein, damit das Program abgeschlossen ist \cite[]{Pet2015}. 

\subsection{Blocking vs Non-Blocking}

Beim behandeln von I/O Operationen kann eine Applikation dem Betriebssystem mitteilen wie die I/O Operation ausgeführt werden soll. Wird der Blocking Modus verwendet, so wartet das Program so lange bis alle Daten eingelesen wurden und bereit für die Weiterverarbeitung sind. Im Unterschied zum Blocking Mode wartet die Applikation nicht bis alle Daten eingelesen wurden. Die Funktion welche die I/O Operation ausführt leitet die Aufgabe (z.B. das einlesen einer Datei) an das Betriebssystem weiter und kehrt sofort zur aufrufenden Funktion zurück \cite[p. 47]{Erb2012}. Im Fall von NodeJS wird eine Callback Funktion hinterlegt, welche aufgerufen wird, wenn die I/O Operation abgeschlossen ist. Dadurch kann NodeJS in der Zwischenzeit andere Operationen ausführen. 

\subsection{Das synchrone Model}

Im synchronen Model werden Aufgaben sequentiell abgearbeitet. Dabei wird eine Initialaufgabe aufgerufen und von dieser ausgehend alle anderen Aufgaben sequentiell abgearbeitet. Ist eine Aufgabe fertig wird die nächste Aufgabe ausgeführt. Sind alle Aufgaben abgeschlossen so terminiert das Program. Der Programverlauf ist im synchronen Model Linear und kann in einer Zeitachse wie in Abbildung (TODO: add Image) dargestellt werden \cite[]{Pet2015}.

(TODO: add image)

\subsection{Das asynchrone Model}

Im asynchronen Model kehren Aufgaben sofort zum Ursprung zurück ohne dass die Aufgabe tatsächlich abgeschlossen ist. In der Zwischenzeit kann die Applikation weitere Aufgaben ausführen. 


\subsection{Das blockierenden und synchron Model}
Im blockierenden und synchronen Model werden einzelne Operationen sequentiell abgearbeitet. Wird in diesem Model eine I/O Operation an das Betriebssystem geschickt, wird der Prozess so lange pausiert bis die I/O Operation abgeschlossen ist. Dannach wird 





In diesem Model werden einzelne Operationen in kleinere Sektionen verpackt. Angenommen der Task 1 ist verantwortlich um auf Eingaben des Benutzers zu reagieren, so könnte das synchrone Model diese Eingaben nur in der ersten Phase annehmen. In den restlichen 2 drittel der Laufzeit könnten so keine Eingaben von einem Benutzer erfolgen.

Ein Grund warum das asynchrone Model schneller sein kann als das synchrone Model sind I/O Operationen die den Prozess blockieren\ref{subsection: io_operationen}. Möchte die Aufgabe 2 eine Datei von der Festplatte einlesen so versetzt das den Prozess in einen Ruhezustand bis die Datei fertig eingelesen wurde. In einem synchronen Program können in dieser Zeit keine weiteren Operationen ausgeführt werden. Die Idee der asynchronen Programmierung ist diese Zeit zu nutzen um andere Aufgaben in der Zwischenzeit zu erledigen \cite[]{Pet2015}. 

Asynchrone Programmierung führt eine Aufgabe so lange aus bis diese entweder abgeschlossen ist, oder blockiert. Dadurch können asynchrone Programme schneller sein als synchrone, weil sich diese weniger Zeit im Ruhezustand befinden.  

