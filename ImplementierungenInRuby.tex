\section{Implementierungen in Ruby}
\label{section:implementation}

In diesem Kapitel werden drei unterschiedliche Implementierungen vorgestellt, welche 10 Fotos über das Netzwerk von einer externen Ressource downloaden. Dabei wird der online dummy Bilder Service placehold.it verwendet. Um die Bilder in Ruby herunterladen zu können wird die Bibliothek \emph{HTTP} aus dem Modul \emph{Net} verwendet \footnote{Die Dokumentation findet man unter: \url{http://ruby-doc.org/stdlib-2.2.2/libdoc/net/http/rdoc/Net/HTTP.html}}.

Der gesamte Source Code zu den Beispielen findet sich auf Github: \url{https://github.com/webPapaya/concurrency-in-ruby}.


\subsection{Iterative Implementierung}

In der folgenden Implementierung werden 10 Bilder von placehold.it heruntergeladen.

\begin{lstlisting}[
	caption={Download der Bilder},
	label=listing:image_algorithm
]
	require 'benchmark'
	require 'net/http'

	def download_images
	  images = Array.new(10) { |idx| "http://placehold.it/350x1#{idx*100}" }
	  images.each do |image_url|
	    uri = URI(image_url)
	    Net::HTTP.get(uri)
	  end
	end

	Benchmark.bm do |x|
	  10.times do |iteration|
	    x.report("futures: #{iteration}") { download_images }
	  end
	end
\end{lstlisting}

In Listing \ref{listing:image_algorithm} werden die Bibliotheken Benchmark und Net/HTTP inkludiert. Die wichtigste Zeile in diesem Beispiel ist die Zeile 8. Darin wird ein HTTP Get Request an die Domain placehold.it mit dem Pfad zum Bild gesendet. In diesem Beispiel blockiert dieser Aufruf den Hauptthread bis das Bild heruntergeladen wurde. Ist der HTTP Request beendet so wiederholt sich der vorgang bis alle 10 Bilder heruntergeladen wurden. 

Diese Implementierung ist nicht optimal da durch den blockierenden der I/O Operation in Zeile 8 der Main Thread zum stillstand kommt. 


\subsection{Futures Implementierung}

Die folgende Implementierung verwendet Futures um die 10 Bilder von \emph{placehold.it} über das Netzwerk herunterzuladen.

\begin{lstlisting}[
	caption={Download der Bilder},
	label=listing:futures_implementierung
]
	require 'benchmark'
	require 'net/http'

	class Future
	  def self.call(&block)
	    Future.new block
	  end

	  def initialize(block)
	    @thread = Thread.new { block.call }
	  end

	  def value
	    @thread.value
	  end

	  def status
	    @thread.status
	  end
	end

	def download_images
	  images = Array.new(10) { |idx| "http://placehold.it/350x1#{idx*100}" }
	  downloads = images.map do |image_url|
	    Future.call do
	      uri = URI(image_url)
	      Net::HTTP.get(uri)
	    end
	  end
	  downloads.each(&:value)
	end

	Benchmark.bm do |x|
	  10.times do |iteration|
	    x.report("futures: #{iteration}") { download_images }
	  end
	end
\end{lstlisting}

Listing \ref{listing:futures_implementierung} zeigt die Implementierung einer Futures Klasse wie sie in Kapitel \ref{section:futures} behandelt wurde. Die Klasse besitzt eine statische Funktion \emph{call} welcher man einen Block übergeben kann, der die Berechnung des Wertes beinhaltet. Diese erstellt ein neues Futures Objekt und übergibt dem Konstruktor einen Block. In der Konstruktorfunktion der Features Klasse wird ein neuer Thread erzeugt in dem der übergebene Block ausgeführt wird. Des weiteren gibt es in der Futures Klasse zwei weitere Methoden \emph{value} und \emph{status}. Die Methode \emph{value} gibt den Rückgabewert des Blocks an den Aufrufer zurück. Dabei wird der Thread des Aufrufers so lange blockiert bis der Rückgabewert des Blocks verfügbar ist. Die Methode \emph{status} gibt den aktuellen Status des Futures zurück.

Die Funktion \emph{download\_images} erstellt ein Array von Bildern welche von placehold.it heruntergeladen werden sollten. Bei der Iteration über die Bilder wird die statische Methode Future.call aufgerufen, welcher ein Block übergeben wird. Dieser Block kümmert sich um das Herunterladen der Bilder. Durch die Verwendung des Futures werden alle Bilder asynchron heruntergeladen. In Zeile 30 wird über alle Futures iteriert und die Methode \emph{value} aufgerufen. Dadurch wird der Hauptthread mit den Futures synchronisiert und blockiert so lange bis alle Bilder heruntergeladen wurden. 

Durch die Verwendung von Futures können Berechnungen oder I/O concurrent oder auch parallel ausgeführt werden. Die Implementierung der Futures Klasse besitzt dabei weniger als 20 Zeilen an Code. Durch die Verwendung von Futures kann die Applikation mehrere HTTP Get Requests gleichzeitig an \emph{placehold.it} versenden ohne dass der Main Thread auf jeden einzelnen HTTP Get Response warten muss bevor er das nächste Bild anfragt. 

\subsection{Actor Based Model}

Die folgende Implementierung verwendet das Actor Based Model um die 10 Bilder von placehold.it herunterzuladen. Dafür müssen wir uns zuerst die Implementierung des Actor Based Models genauer ansehen \footnote{Datei: \url{https://github.com/webPapaya/concurrency-in-ruby/blob/master/actor_based_model/actor.rb}}.

In der Datei \emph{actor.rb} werden drei unterschiedliche Klassen erstellt.

\begin{itemize}
  \item ActorPool
  \item Actor
  \item ActorProxy
\end{itemize}

Der \emph{ActorPool} ist ein Singelton Objekt welches für die Verwaltung aller Aktoren verantwortlich ist. 

\begin{lstlisting}[
	caption={Die Singelton Klasse ActorPool},
	label=listing:actor_pool
]
class ActorPool
  include Singleton

  def initialize
    @queue = Queue.new
  end

  def add(actor)
    @queue.push actor
  end

  def shutdown
    until @queue.length == 0 do
      actor = @queue.pop
      actor.shutdown
    end
  end
end
\end{lstlisting}

Da die Aktoren mit Threads arbeiten würden diese entfernt werden sobald der Main Thread das Ende der Applikation erreicht. Um das zu verhindern bietet der Actor Pool mit der Methode \emph{shutdown} die Möglichkeit alle Aktoren herunterzufahren. Das Herunterfahren eines Aktors bedeutet, dass keine weiteren Nachrichten mehr hinzugefügt werden können und die Nachrichten welche sich aktuell in der Mailbox befinden noch abgearbeitet werden. Um die einzelnen Aktoren zu verwalten verwendet die Klasse die Datenstruktur Queue aus dem Modul Thread. In der Methode \emph{add} werden einzelne Aktoren der Queue hinzugefügt. 

Nachdem die Aktor Implementierung die Möglichkeit bieten soll aus jeder Ruby Klasse einen Aktor zu machen benötigt diese Implementierung einige Meta Programming Features von Ruby. 

\begin{lstlisting}[
	caption={Die Singelton Klasse ActorPool},
	label=listing:actor_meta
]
module Actor
  module ClassMethods
    def new(*)
      ActorProxy.new(super)
    end
  end

  class << self
    def included(klass)
      klass.extend(ClassMethods)
    end
  end
  ...
\end{lstlisting}


Listing \ref{listing:actor_meta} zeigt einen Auszug aus dem Modul Actor. In diesem Modul \emph{Actor} wird ein weiteres Modul ClassMethods erstellt. Dieses Modul besitzt die Methode new. Diese erstellt ein neues ActorProxy Objekt und ruft mit dem Keyword \emph{super} die Methode \emph{new} der eigentlichen Klasse auf. Um die Methode \emph{new} in der eigentlichen Klasse zu überladen werden in Zeile 10 alle Methoden des Moduls ClassMethods dem eigentlichen Objekt hinzugefügt. 

\begin{lstlisting}[
	caption={Die Singelton Klasse ActorPool},
	label=listing:actor_in_use
]
class Test
  include Actor
end

puts Test.new.class # Actor::ActorProxy
\end{lstlisting}

Listing \ref{listing:actor_in_use} zeigt eine einfache Klasse welches das Modul Actor inkludiert.  Wird aus der Klasse ein neues Objekt mit dem Stichwort \emph{new} erstellt wird nicht der Standard Konstruktor aufgerufen, sondern der überladene Konstruktor des Moduls Actor. Dieser erstellt ein neues ActorProxy Objekt und ruft mit dem Stichwort \emph{super} den Konstruktor der Klasse Test auf. Das neu erstellte Objekt vom Typ \emph{Test} wird dem Konstruktor von ActorProxy übergeben. Durch das Überladen der Methode \emph{new} wird kein Objekt vom Typ Test zurückgeliefert, sondern ein Objekt vom Typ Actor::ActorProxy. Durch dieses Konstrukt 
werden alle Methoden über das ActorProxy Objekt abgewickelt.

Die ActorProxy Klasse besitzt folgende Methoden:

\begin{itemize}
  \item method\_missing
  \item shutdown
  \item process\_inbox
  \item process\_message
\end{itemize}

Die Methode \emph{method\_missing} ist eine Ruby interne Methode welche es erlaubt nicht definierte Methoden eines Objekts abzufangen und zu behandeln. Dieses Konzept wird genutzt um den Namen einer Methode des Basisobjekts in eine Nachricht zu verwandeln, und anschließend der Mailbox hinzuzufügen. Listing \ref{listing:actor_method_missing} zeigt die Methode \emph{method\_missing} in der \emph{ActorProxy} Klasse. 

\begin{lstlisting}[
	caption={Aktor method\_missing},
	label=listing:actor_method_missing
]

def method_missing(method, *args)
  @mailbox.push [method, args]
  process_inbox
end
\end{lstlisting}


Wurde einem Aktor eine neue Nachricht hinzugefügt wird diese in der Methode \emph{process\_inbox} abgearbeitet. 

\begin{lstlisting}[
	caption={Aktor process_inbox},
	label=listing:actor_process_inbox
]

def process_inbox
  @threads << Thread.new do
    method, args = @mailbox.pop
    process_message method, args
  end
end
\end{lstlisting}	

Dabei wird ein neuer Thread erstellt welcher die einzelnen Nachrichten abarbeitet. Die einzelnen Nachrichten werden in der Methode \emph{process\_message} abgearbeitet. Um Race Conditions zu vermeiden wird beim Aufruf der eigentlichen Methode mutex.synchronize aufgerufen. 


\begin{lstlisting}[
	caption={Aktor process_message},
	label=listing:actor_method_missing
]

def process_message(method, args)
  @mutex.synchronize do
    @target.public_send method, *args
  end
end
\end{lstlisting}	

Durch die Verwendung des vorher beschriebenen Actor Based Models werden alle Methodenaufrufe eines Objekts welche das Modul \emph{Actor} inkludiert haben asynchron abgearbeitet. Eine Klasse welche diese Implementierung des Actor Based Models verwendet ist die Klasse \emph{ImageDownload}:

\begin{lstlisting}[
	caption={Aktor process_message},
	label=listing:actor_image_download
]

require_relative 'actor'
require 'net/http'

class ImageDownload
  include Actor

  def initialize(image_url)
    @image_url = URI(image_url)
  end

  def download
    Net::HTTP.get @image_url
  end
end
\end{lstlisting}

In Listing \ref{listing:actor_image_download} wird eine Klasse erstellt welche das Modul Actor inkludiert. Dem Konstruktor muss ein Bild URL übergeben werden und wird die Methode download aufgerufen, so wird das Bild automatisch asynchron und nicht blockierend heruntergeladen. Durch die Verwendung dieser Implementierung können nicht blockierende Programme geschrieben werden. 

\subsection{Reactor Pattern}
Für die Implementierung des Reactor Patterns wird die Bibliothek Eventmachine\footnote{EM auf Github: \url{https://github.com/eventmachine/eventmachine}} verwendet. 

Auf der Github Seite beschreibt sich Eventmachine wie folgt: 

	``EventMachine is an event-driven I/O and lightweight concurrency library for Ruby. It provides event-driven I/O using the Reactor pattern, much like JBoss Netty, Apache MINA, Python's Twisted, Node.js, libevent and libev.'' (\url{https://github.com/eventmachine/eventmachine})

Eventmashine verwendet eine nicht blockierende EventLoop bei I/O Operationen. 